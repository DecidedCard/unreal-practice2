# Unreal Practice2

## 1강 언리얼 엔진 게임 제작 기초

### 게임 콘텐츠의 구조

- 게임 제작을 위해 언리얼 엔진은 자체적으로 설계한 프레임웍을 제공함.
- 이를 게임플레이 프레임웍이라고 부름.
- 언리얼 게임 프레임웍의 각 구성 요소를 파악하고, 이를 확장하면서 게임을 제작하는 것을 권장

### 월드

- 게임 콘텐츠를 담기 위해 제공되는 가상의 공간
- 월드는 시간, 트랜스폼, 틱을 서비스로 제공한다.
- 월드 세팅이라는 콘텐츠 제작을 위한 기본 환경 설정을 제공한다.
- 월드의 기본 단위는 액터로 정의되며, 액터 클래스틑 언제나 접두사 A를 사용한다.

### 게임모드

- 게임 규칙을 지정하고 게임을 판정하는 최고 관리자 액터, 형태가 없다.
- 언리얼 엔진에서 하나의 게임에는 반드시 하나의 게임 모드만 존재한다.
- 게임 모드에서 입장할 사용자의 규격을 지정할 수 있음.
- 멀티플레이어 게임에서 판정을 처리하는 절대적 권위의 심판

### 기믹

- 게임 진행을 위한 이벤트를 발생시키는 사물 액터
- 주로 이벤트 발생을 위한 충돌 영역을 설정하는데, 이를 트리거라고 한다.
- 트리거를 통해 캐릭터와 상호 작용하고, 월드에 액터를 스폰해 콘텐츠를 전개한다.

### 플레이어

- 게임에 입장한 사용자 액터. 형태가 없다.
- 게임 모드의 로그인을 통해 사용자가 게임 월드에 입장하면 플레이어가 생성된다.
- 싱글 플레이 게임에는 0번 플레이어가 설정된다.
- 사용자와의 최종 커뮤니케이션을 담당한다.

### 폰

- 무형의 액터인 플레이어가 빙의해 조종하는 액터
- 길찾기를 사용할 수 있으며, 기믹 및 다른 폰과 상호작용한다.
- 폰 중에서 인간형 폰을 별도로 캐릭터라고 지칭한다.

### 정리

- 게임 콘텐츠 구조의 이해
- 게임 프레임웍의 구성 요서 살펴보기
- 단순한 게임 구조에서 출발해 점점 복잡한 게임으로 확장하는 제작 과정을 이해
- C++ 프로젝트 구성을 위한 기본 설정
- 게임 구성 요소를 폴더별로 분류하고, 헤더 참조를 최소화하는 규칙 수립

## 2강 캐릭터와 입력 시스템

### 액터의 구조

- 월드에 속한 콘텐츠의 기본 단위를 액터라고 함.
- 액터는 트랜스폼을 가지며, 월드로부터 틱과 시간 서비스를 제공받는다.
- 사실 액터는 논리적 개념일 뿐 컴포넌트를 감싸는 포장 박스에 불과함.
- 실질적인 구현은 컴포넌트가 진행하고 액터는 다수의 컴포넌트를 소유하고 있음.
- 다수의 컴포넌트를 대표하는 컴포넌트를 루트 컴포넌트라고 한다.
- 액터는 루트 컴포넌트를 가져야 하며, 루트 컴포넌트의 트랜스폼은 액터의 트랜스폼을 의미한다.

### C++ 액터에서 컴포넌트의 생성

- 컴포넌트는 언리얼 오브젝트이므로 UPROPERTY를 설정하고 TObjectPtr로 포인터를 선언한다.
  - 언리얼 5버전부터 헤더에 언리얼 오브젝트를 선언할 때 일반 포인터에서 TObjectPtr로 변경
- 컴포넌트 등록
  - CDO에서 생성한 컴포넌트는 자동으로 월드에 등록된다.
  - NewObject로 생성한 컴포넌트는 반드시 등록절차를 거쳐야 한다.
  - 등록된 컴포넌트는 월드의 기능을 사용할 수 있으며, 물리와 렌더링 처리에 합류한다.
- 컴포넌트의 확장 설계
  - 에디터 편집 및 블루프린트로의 승계를 위한 설정
  - UPROPERTY에 지정자를 설정할 수 있다.
- 컴포넌트 지정자
  - Visible / Edit: 크게 객체타입과 값타입으로 사용
  - Anywhere / DefaultsOnly / InstanceOnly: 에디터에서 편집 가능 영역
  - BlueprintReadOnly / BlueprintReadWrite: 블루프린트로 확장시 읽기 혹은 읽기쓰기 권한을 부여
  - Category: 에디터 편집 영역에서의 카테고리 지정

### 폰의 기능과 설계

- 폰은 액터를 상속받은 특별한 액터이며, 플레이어가 빙의해 입출력을 처리하도록 설계되어 있음.
- 폰은 길찾기를 사용할 수 있으며, 일반적으로 세 가지 주요 컴포넌트로 구성된다.
  - 기믹과 상호작용을 담당하는 충돌 컴포넌트 (루트컴포넌트)
  - 시각적인 비주얼을 담당하는 메시 컴포넌트
  - 움직임을 담당하는 컴포넌트
- 컴포넌트 중에서 트랜스폼 없이 기능만 제공하는 컴포넌트를 액터컴포넌트라고 한다.

### 캐릭터의 기본 구조

- 캐릭터는 인간형 폰을 구성하도록 언리얼이 제공하는 전문 폰 클래스를 의미한다.
- 캐릭터는 세 가지 주요 컴포넌트로 구성되어 있다.
  - 기믹과 상호작용을 담당하는 캡슐 컴포넌트 (루트컴포넌트)
  - 애니메이션 캐릭터를 표현하는 스켈레탈 메시 컴포넌트
  - 캐릭터의 움직임을 담당하는 캐릭터 무브먼트(CharacterMovement) 컴포넌트

### 입력 시스템의 동작 방식

- 플레이어의 입력은 컨트롤러를 통해 폰으로 전달됨.
- 입력을 컨트롤러가 처리할 수도, 폰이 처리할 수도 있는데, 일반적으로는 폰이 처리하도록 설정
  - 예) GTA같은 다양한 사물에 빙의하는 게임의 경우 폰이 유리

### 향상된 입력시스템

- 기존 입력시스템을 대체하고 언리얼 5.1부터 새롭게 도입
- 사용자의 입력 설정 변경에 유연하게 대처할 수 있도록 구조를 재수립
- 사용자 입력 처리를 네 단계로 세분화하고 각 설정을 독립적인 애셋으로 대체

### 향상된 입력시스템 동작 구성

- 사용자의 입력 데이터를 최종 함수에 매핑하는 과정을 체계적으로 구성
- 플랫폼에 따른 다양한 입력 장치의 설정
  - 예) 게임패드용 입력 매핑 컨텍스트, 키보드용 입력 매핑 컨텍스트
- 입력 값의 변경
  - 예) AD/WS 입력값을 Y축과 X축으로 변경, 값 반전의 처리
- 이벤트 발생 조건의 상세 설정
  - 예) 일반 버튼인가? 축 이동인가? 일정 이상 눌러야 하는가?

### 정리

- 액터와 컴포넌트 개념의 이해
- 컴포넌트 속성에 지정자를 추가해 블루프린트로 확장하는 방법의 이해
- 폰과 캐릭터를 구성하는 3대 구성 요소
- 언리얼 5.1에서 추가된 향상된 입력 시스템의 사용 방법

## 3강 캐릭터 컨트롤

### 캐릭터 컨트롤

- 일반적으로 컨트롤러와 폰, 카메라, 스프링암, 캐릭터 무브먼트의 다섯 가지 요소를 사용해 설정.
- 컨트롤러: 입력자의 의지을 지정할 때 사용. ControlRotation 속성
- 폰: 폰의 트랜스폼을 지정
- 카메라 : 화면 구도를 설정하기 사용. 주로 1인칭 시점에서 사용
- 스프링 암 : 화면 구도를 설정하기 위해 사용. 주로 3인칭 시점에서 사용
- 캐릭터 무브먼트: 캐릭터의 이동과 회전을 조정하는 용도로 사용

### 폰의 이동 함수

- Look 함수 : 마우스 입력으로부터 컨트롤러의 컨트롤 회전을 설정
- Move 함수 : 컨트롤러의 컨트롤 회전으로부터 Yaw 값을 참고해 이동 방향을 설정
- 콘솔 커맨드 창으로부터 Control Rotation 값을 확인할 수 있음.

### 폰의 컨트롤 옵션

- Use Controller Rotation (Yaw/Roll/Pitch)
- 컨트롤러에 지정된 Control Rotation 값에 폰의 Rotation을 맞출 것인가?
- 이 옵션을 켜면 폰의 회전은 컨트롤러의 Control Rotation과 동기화됨.

### 스프링암의 컨트롤 옵션

- Use Pawn Control Rotation
- Inherit (Yaw/Roll/Pitch)
- Do Collision Test
- 폰의 컨트롤 회전( 컨트롤러의 Control Rotation )을 사용할 것인가?
- 부모 컴포넌트 ( 주로 RootComponent ) 의 회전을 그대로 따를 것인가?
- 스프링암 중간에 장애물이 있으면 앞으로 당길 것인가? ( Camera라는 트레이스 채널을 사용 )
- 3인칭 시점 설정에 주로 사용

### 카메라의 컨트롤 옵션

- Use Pawn Control Rotation
- 폰의 컨트롤 회전 ( 컨트롤러의 Control Rotation )을 사용할 것인가?
- 스프링암에 달려 있다면 스프링암의 회전과 함께 고려
- 1인칭 카메라 회전에 주로 사용

### 캐릭터 무브먼트의 이동 옵션

- Movement Mode : None, Walking, Falling
- 땅 (Ground)위에 있으면 Walking 모드
- 땅 위에 없으면 Falling 모드
- 이동 기능을 끄고 싶으면 None 모드
- 이동 모드에서의 이동 수치 : MaxWalkSpeed
- 폴링 모드에서의 점프 수치 : JumpZVelocity

### 캐릭터 무브먼트의 회전 옵션

- Rotation Rate : 회전 속도의 지정
- Use Controller Desired Rotation : 컨트롤 회전을 목표 회전으로 삼고 지정한 속도로 돌리기
- Orient Rotation To Movement : 캐릭터 이동 방향에 회전을 일치시키기
- 폰의 회전 옵션과 충돌이 나지 않도록 주의

### 데이터 애셋

- UDataAsset을 상속받은 언리얼 오브젝트 클래스
- 에디터에서 애셋 형태로 편리하게 데이터를 관리할 수 있음.
- 캐릭터 컨트롤에 관련된 주요 옵션을 모아 애셋으로 관리

### 데이터 애셋의 관리

- 두 가지의 컨트롤 모드를 제공
  - 현재 구현된 컨트롤 모드 : 3인칭 솔더뷰
  - 추가로 구현할 컨트롤 모드 : 3인칭 쿼터뷰
- 입력키 V를 통해 컨트롤 설정을 변경
- ENUM을 통해 두 개의 컨트롤 데이터를 관리

### 데이터 애셋의 구성과 적용

- 각 섹션별로 데이터를 저장
  - Pawn 카테고리
  - 캐릭터 무브먼트 카테고리
  - 입력 카테고리
  - 스프링암 카테고리
- Pawn과 캐릭터무브먼트 데이터는 CharacterBase에서 설정
- 입력과 스프링암 데이터는 CharacterPlayer에서 설정

### 정리

- 컨트롤러에 설정된 ControlRotation 속성의 이해
- 캐틱터의 움직임과 회전을 설정하는 다양한 구성 요소와 설정 값의 이해
- 입력 매핑 콘텍스트를 활용한 뷰의 변환 구현

## 4강 캐릭터 애니매이션 설정

### 캐릭터 애니메이션 시스템의 생성

- 스켈레탈 메시 컴포넌트의 애니메이션 플루프린트 클래스를 지정한다.
- 캐릭터가 초기화될 때 AnimInstance 클래스의 인스턴스를 생성한다.
- 캐릭터는 GetAnimInstance 함수를 사용해 애니메이션 인스턴스를 얻을 수 있음
- 애니메이션 인스턴스는 GetOwningActor 함수를 사용해 자신을 소유한 액터 정보를 얻을 수 있음

### 캐릭터 애니메이션 시스템의 설계

- 애니메이션 블루프린트는 이벤트 그래프와 애님 그래프의 두 영역으로 구성되어 있음.
- 이벤트 그래프에서는 이벤트로부터 상태를 파악할 수 있는 주요 변수를 저장하는데 사용
- 애님 그래프에서는 저장된 변수로부터 지정된 상태의 애니메이션을 재생
- 애님 그래프의 복잡한 상태는 State Alias로 분리해 효과적으로 설계할 수 있음

### 정리

- C++ 클래스를 상속받은 애니메이션 플루프린트의 생성 방법의 이해
- 이벤트 그래프와 애님 그래프로 구성된 애니메이션 블루프린트의 구조 파악
- 애님 그래프를 사용한 애니메이션 시스템의 설계 방법의 학습

## 5강 캐릭터 콤보 액션

### 애니메이션 몽타주

- 몽타주(Montage) : 이미지 일부를 잘라내 한 화면에서 합성하는 회화 기법
- 애니메이션 클립을 잘라내고 합성한 후 이를 재생하는 애니메이션 기능
- 애니메이션 클립을 모아둔 다수의 섹션으로 구성되어 있음
- 섹션끼리 연동할 수 있으며, 스크립트를 통해 원하는 섹션으로 건너뛸 수 있음.

### 정리

- 애니메이션 몽타주 활용 방법의 이해
- 데이터 애셋을 활용한 콤보 로직의 구현
- 언리얼 델리게이트를 사용한 이벤트 콜백의 구현

## 6강 캐릭터 공격 판정

### 캐릭터 액션의 충돌 판정

- 월드가 제공하는 충돌 판정 서비스를 사용
- 월드는 크게 세가지의 충돌 판정 서비스를 제공함.
- 월드 내 배치된 충돌체와 충돌하는지 파악하고, 충돌한 액터 정보를 얻을 수 있음.

### 트레이스 채널과 충돌 프로필 생성

- 액션 판정을 위한 트레이스 채널의 생성 : ABAction. 기본 반응은 무시
- 캐릭터 캡슐용 프로필 : ABAction 트레이스 채널에 반응. 오브젝트 타입은 Pawn
- 스켈레탈 메시용 프로필 : 랙돌 구현을 위해 주로 활용됨.
- 기믹 트리거용 프로필 : 폰 캡슐에만 반응하도록 설정. 오브젝트 타입은 WorldStatic

### 월드 트레이싱 함수의 선택

- 세 가지 카테고리로 원하는 함수 이름을 얻을 수 있음.
- 카테고리 1 : 처리 방법
- 카테고리 2 : 대상
  - Test : 무언가 감지되었는지를 테스트
  - Single 또는 AnyTest : 감지된 단일 물체 정보를 반환
  - Multi : 감지된 모든 물체 정보를 배열로 반환
- 카테고리 3 : 처리 설정
  - ByChannel : 채널 정보를 사용해 감지
  - ByObjectType : 물체에 지정된 물리 타입 정보를 사용해 감지
  - ByProfile : 프로필 정보를 사용해 감지

### 캐릭터 공격 판정의 구현

- 캐릭터의 위치에서 시선 방향으로 물체가 있는지 감지
- 작은 구체를 제작하고 시선 방향으로 특정 거리까지만 투사.
- 하나의 물체만 감지
- 트레이스 채널을 사용해 감지

### 물리 충돌 테스트

- 디버그 드로잉 함수를 사용해 물리 충돌을 시각적으로 테스트
- 90도로 회전시킨 캡슐을 그리기
  - Origin
  - HalfHeight
  - Radius

### 정리

- 공격 판정 구현을 위한 물리 트레이스 채널 및 프로필 설정
- 디버그 드로잉 기능을 활용한 충돌 디버깅
- 대미지 프레임웍을 사용한 대미지 전달
- 델리게이트와 람다함수의 간편한 활용

## 7강 캐릭터 스탯과 위젯

### 액터 컴포넌트를 활용한 스탯의 설계

- 액터에 부착할 수 있는 컴포넌트 중 트랜스폼이 없는 컴포넌트
- 액터의 기능을 확장할 때 컴포넌트로 분리해 모듈화할 수 있음
- 스탯 데이터를 담당하는 컴포넌트와 UI 위젯을 담당하는 컴포넌트로 분리
- 액터는 두 컴포넌트가 서로 통신하도록 중개하는 역할로 지정

### 언리얼 델리게이트를 활용한 발행 구독 모델의 구현

- 푸시(Push) 형태의 알림(Notification)을 구현하는데 적합한 디자인 패턴
- 스탯이 변경되면 델리게이트에 연결된 컴포넌트에 알림을 보내 데이터를 갱신
- 스탯 컴포넌트와 UI 컴포넌트사이의 느슨한 결합의 생성

### 액터의 라이프 싸이클

- 월드에서 액터가 초기화되고 소멸되는 프로세스
  > 액터를 최종으로 마무리하고 할 때 PostInitializeComponents라는 함수를 통해서 마무리를 하고
  > 시작할때 초기화를 하고 싶으면 BeginPlay에서 작업을 함.
  > PostInitializeComponents는 Tick이 시작되지 않고 BeginPlay는 Tick이 시작됨.

### 위젯 컴포넌트와 위젯

- 위젯 컴포넌트는 액터 위에 UI 위젯을 띄우는 컴포넌트
- 3차원 모드와 2차원 모드를 지원함
- 위젯 컴포넌트는 컨테이너 역할만 할 뿐, 둘은 서로 독립적으로 동작함

### 위젯 컴포넌트의 초기화 과정

- 발행 구독 모델의 구현을 위해 위젯 컴포넌트의 초기화 단계를 파악할 필요가 있음.
- UI 관련 컴포넌트는 액터의 BeginPlay이후에 호출되고 있음.
- 생성시 InitWidget 함수와 NativeConstruct 함수를 호출
- 차후에 변경될 가능성도 염두해 두어야 함.

### 위젯 컴포넌트와 위젯의 확장

- 위젯에 소유한 액터 정보를 보관할 수 있도록 클래스를 확장 (ABUserWidget)
- 위젯 컴포넌트 초기화 단계에서 이를 설정할 수 있도록 클래스를 확장 (ABWidgetComponent)
- 위젯 초기화 단계에서 부모 클래스 정보를 읽고 자신을 등록 (ABCharacterWidgetInterface)

### 정리

- 액터 컴포넌트를 사용해 캐릭터가 가진 기능을 분산
- 언리얼 델리게이트를 활용한 발행 구독 모델의 구현
- 위젯 컴포넌트 초기화 시점을 파악하기 위한 기존 클래스 구조의 확장 설계

## 8강 아이템 시스템

### 트리거 빅스의 구현

- 루트에 트리거를 설정하고 자식에 메시 컴포넌트를 부착
- 이펙트는 기본 값으로 비활성화 상태로 두고 오버랩 이벤트 발생시 발동되도록 설정
- 이벤트 종료시 액터가 제거되도록 설정
